global _start

%include "../lab1/lib.inc"

%define pc r12
%define w r13
%define rstack r14
%define here r15

%define link 0 ; Указатель на предыдущее слово отсутствует

%macro native 3
; %1 %2 %3
section .data

w_%2:
    dq link ; Указатель на предыдущее слово
    %define link w_%2
    db %1, 0 ; Имя слова
    db %3 ; Флаги
xt_%2:
    dq %2_impl

section .text
    %2_impl:
%endmacro

%macro native 2
native %1, %2, 0
%endmacro

%macro colon 3
; %1 %2 %3
w_%2:
    dq link ; Указатель на предыдущее слово
    %define link w_%2
    db %1, 0 ; Имя слова
    db %3 ; Флаги

    dq docol ; Адрес docol - 1 уровень косвенности
%endmacro

%macro colon 2
colon %1, %2, 0
%endmacro

section .data
res1: db 'Good', 0
res2: db 'Not good', 0

program_stub: dq 0
xt_interpreter: dq .interpreter
.interpreter: dq interpreter_loop

section .text
_start:

mov pc, xt_interpreter
jmp next

interpreter_loop:
	call read_word
	test rdx, rdx
	jz .exit

	mov rdi, rax
	push rdi
	call find_word
	pop rdi

	test rax, rax
	jnz .found
	jz .not_found

	.found:
		mov rdi, rax
		call cfa
		mov qword[program_stub], rax
		mov pc, program_stub

		; debug
		mov rdi, res1
		call print_string
		call print_newline

		jmp next ; +

	.not_found:
		; if [rdi] - это число
		call parse_int
		test rdx, rdx
		jnz .number
		jz .not_number

		.number:
		push rax

		; debug
		mov rdi, res1
		call print_string
		call print_newline

		jmp interpreter_loop

		.not_number:
		; Ошибка! Неизвестное слово

	.exit:
		; ...

section .data
; colon-слова:

colon 'double', double
    dq xt_dup
    dq xt_plus
    dq xt_exit

section .text

; Реализации:

native 'exit', exit
	mov pc, [rstack]
	add rstack, 8
	jmp next

native '+', plus
	; debug
	    mov rdi, [rsp]
		call print_int
		call print_newline

	; debug
	    mov rdi, [rsp + 8]
		call print_int
		call print_newline

    pop rax
    add rax, [rsp]
    mov [rsp], rax      ;add [rsp], rax ; А так можно? О_о

    ; debug
	    mov rdi, [rsp]
		call print_int
		call print_newline

    jmp next

native 'dup', dup
    push qword[rsp]
    jmp next

native 'mem', mem ;?
	push bss_buf
	jmp next

next:
	mov w, pc
	add pc, 8
	mov w, [w]
	jmp [w]

; Для colon-слов:
docol:
	sub rstack, 8
	mov [rstack], pc
	add w, 8
	mov pc, w
	jmp next

; Дополнительные процедуры:
find_word:
	; rdi - указатель на имя искомой процедуры
    ; rax - вернуть адрес слова, либо 0
	; Начать проверять с link

    ; mov byte[string_buf], rdi
    ; mov rdi, string_buf

    lea r8, [link]

    .iterate:
        ; r8 - текущее проверяемое слово
        ; [r8] - следующее проверяемое слово

        mov rsi, r8
        add rsi, 8

        push rdi
        push r8
        call string_equals
        pop r8
        pop rdi

        test rax, rax
        jz .not_good
        jnz .good

        .good:
            mov rax, r8
            ret

        .not_good:
            mov r8, [r8]
            test r8, r8
            jnz .iterate

            mov rax, 0
            ret

cfa:
	; rdi - адрес w_...
	; rax - будет xt_...

	add rdi, 8

	push rdi
	call string_length
	pop rdi

	lea rax, [rdi + rax + 2] ;!? Ok?!

	ret

section .bss
bss_buf resb 65536
